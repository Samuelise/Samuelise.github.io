{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Samuelise","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"博弈论中组合游戏模型的算法浅析","slug":"博弈论中组合游戏模型的算法浅析","date":"2019-07-08T10:58:30.000Z","updated":"2019-07-08T10:59:05.773Z","comments":true,"path":"2019/07/08/博弈论中组合游戏模型的算法浅析/","link":"","permalink":"http://yoursite.com/2019/07/08/博弈论中组合游戏模型的算法浅析/","excerpt":"","text":"博弈论中组合游戏模型的算法浅析引言 博弈论（Game Theory),又称对策论,或赛局理论，顾名思义，它是研究多个个体或团队之间在特定条件制约下的对局中利用相关方的策略。即，在某特定游戏规则下，参与者在行动之前所准备好的一套完整的行动方案。 博弈论既是现代数学的一个分支，也是运筹学的一个学科. 组合游戏（Combinatorial Games），该类游戏通常有如下特点： 游戏有两个参与者，二者轮流做出决策，且二者的决策都对自己最有利。 当有一人无法做出决策时游戏结束，且判无法做出决策的人负。无论二者如何做出决策，游戏均可在有限步内结， 游戏的某一个状态不可以再次到达，游戏不会出现平局的局面。 任意一个参与者在某一个确定状态可以做出的决策集合只与当前状态有关，而与参与者无关。 NP态理论我们先引入一个概念————NP态理论 P-position：先手必败态。 N-position：先手必胜态。 性质如下： 决策集合为空的局面是P-position。 可以移动到P-position的局面是N-position。 任何决策均只能移动到N-position的局面是P-position。 我们先看一道题，是我第一次接触到组合游戏，也是第一次接触到博弈论的题。题目链接：pb的游戏 游戏内容是这样的：pb先手将给出的自然数分割，割成两个非零自然数，这两个数之和等于原数，之后由zs选择留下这两个数中的一个进行分割，之后再由pb进行选择分割，如此重复。 游戏规则非常简单，我们知道一个简单的结论： 奇数=奇数+偶数 偶数=偶数+偶数 or 偶数=奇数+奇数 分析如下： 对于数字N, $N=1$时，$N$不可再被分割，此时拿到N的参与者的局面为P-position，先手必败。 $N=2$时，N只能被分割为（1，1），将局面移动到了P-position，根据性质，当前 $N=2$的局面为N-position，先手必胜。 $N&gt;2$且$N$为偶数时，那么我只需要将其拆成$a+b$，$a$，$b$均为小于N的奇数，那么我的对手无论选择$a$还是$b$，都必然会拆出一个偶数，而我只要选择那个偶数，就又回到了$N$为偶数的情况，因此，我选择的数永远是偶数，对手选择的数只能是奇数，选择$N=2$的机会永远在我这里，$N$为偶数的局面为N-position，先手必胜。 $N&gt;2$且$N$为奇数时，那么我将其拆成$a+b，a，b$中必然有一个是偶数，即对于奇数$N$，无论我如何选择均会移动到N-position。因此，N为奇数的局面为P-position，先手必败。 综上，$N$为奇数，先手必败；$N$为偶数，先手必胜。 代码如下： 123456789101112131415#include &lt;cstdio&gt;int main()&#123; int n,a scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; scanf(&quot;%d&quot;, &amp;a); if (a &amp; 1)//判断奇偶，奇数的话先手的pb必败，偶数的话先手的pb必胜，这里使用位运算加快速度，简化书写 printf(&quot;zs wins\\n&quot;); else printf(&quot;pb wins\\n&quot;); &#125; return 0;&#125; 这道题非常简单，可以很容易就判断出NP状态对应的局面分别是什么。但对稍微复杂一点的情况，如Nim游戏，其对应的状态集合非常大，直接使用NP状态理论求解时非常复杂，或者虽然可以求解，但效率也是极低的，因为需要对判断每一个局面是N-position还是P-position，即使可以用动态规划或记忆化搜索来进行优化，也很难优化到令人满意的程度。 那么，对于此类问题，有没有一个通用且效率高的算法呢？ 这就需要用到博弈论中极为重要的工具———SG函数和SG定理。我们先不加证明的引入这两个概念。 SG函数 首先定义$mex=(minimal excludant)$运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如,$mex\\{0,1,2,4 \\}=3、mex\\{ 2,3,5\\}=0、mex\\{0 \\}=1$。 对于任意状态 $x$ ， 定义 $SG(x) = mex(S)$,其中 $S$ 是 $x$ 后继状态的SG函数值的集合。如$x$ 有三个后继状态分别为$a,b,c$，那么$SG(x) = mex\\{ SG（a）,SG（b）,SG（c）\\}$。 即， SG\\big(x) =mex\\{ SG\\big(y):y\\in S\\}SG值的意义为，如果SG(x) = 0，那么x是必败态，如果SG(x) != 0,那么x是必胜态。 Sprague-Grundy(SG)定理多个组合游戏的SG函数值是每个组合游戏SG函数值的Nim和。 Nim和是指各个数相异或的结果 即， SG\\big(x_1,x_2,\\ldots,x_n)=SG\\big(x_1)\\oplus SG(x_2)\\oplus\\cdots\\oplus SG(x_n)现在让我们再回过头来看一下Nim游戏。 游戏大致内容为：有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻无法进行任何合法的移动）。 因为一次只能从某一堆里取，所以我们先看只有一堆石子的情况。 假如这一堆有n个石子，那么可取的石子数就为1 ~ n。 $n=1$时，可以取走1个，$SG[1] = mex\\{SG[0] \\}= mex\\{0 \\} = 1$；$n=2$时，可以取走1，2，$SG[2] = mex \\{ SG[1]，SG[0] \\}= mex \\{ 0,1\\} = 2$;$n=3$时，$SG[3] = mex\\{SG[2],SG[1],SG[0] \\} = mex \\{0,1,2 \\}= 3$ ;…..可得下表， n 1 2 3 4 5 6 7 … n SG[n] 1 2 3 4 5 6 7 … n 显然，$SG[n]=n$。 对于$n$个石子,$SG[n]=mex\\{0，1，2…n-1\\} = n$。 那么对于m堆石子，根据SG定理，只需将每一堆的SG值异或起来即可。 代码如下： 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;int t, n;int main() &#123; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int shu; scanf(&quot;%d&quot;, &amp;shu); ans ^= shu;//石子的个数即为该堆石子的SG值 &#125; if (!ans) printf(&quot;No\\n&quot;);//SG值为0时，先手必败 else printf(&quot;Yes\\n&quot;); &#125;&#125; 通过上面的分析不难看出，SG定理其实就是对每一个局面的NP状态进行转移。 下面我们给出严谨的数学证明： 令 $x=(x_1,x_2,…,x_n）, x为当前状态$ , $x’=(x_1,…,x_i’…,x_n),i\\in[1 \\cdots n]$, $b=SG(x_1)\\oplus SG(x_2)\\oplus \\cdots\\oplus SG(x_n)$. 初始条件：有$0\\oplus0\\oplus0\\oplus\\cdots\\oplus0$,所有的子游戏都结束的时候游戏就结束了，此时为P-position，$SG(x)=0$。 证明以下两条： 对于所有非负整数$a&lt;b$,必定有一个状态$x’$,使得$SG(x’)=a$. 没有一个$x$的子状态$x’$,使得$SG(x’)=b$. 证1.：令$d=a\\oplus b,2^k&lt;=d&lt;2^k+1$， 我们有$a$在第$k+1$位为0，$b$在第$k+1$为1，那么必定有一个$SG(x_i)$在二进制表示的第$k+1$位为1， $SG（x_i)\\oplus d&lt;SG(x_i)$，所以必定有$SG（x_i’)=d\\oplus SG（x_i)$, 所以, a=b\\oplus d=SG(x_1)\\oplus \\cdots \\oplus SG(x_n)\\oplus d=SG(x_1)\\oplus\\cdots\\oplus SG(x_i')\\oplus\\cdots\\oplus SG(x_n)即，存在$x’$,使得$SG(x’)=a$ 证2.：$b=SG(x_1)\\oplus …\\oplus SG(x_i)\\oplus…\\oplus SG(x_n)$, $a=SG(x_1)\\oplus …\\oplus SG(x_i’)\\oplus…\\oplus SG(x_n)$, 若$a=b$，则必有$SG（x_i)=SG(x_i’)$，这意味着中间一步没有进行任何改动，显然这是不被允许的。即，不存在一个x的子状态$x’$，使得$SG（x’）=b$。 综上，问题得证。 就Nim游戏来说，它仍是组合游戏模型中较为基础的题，但值得注意的是，该模型下，不同游戏的规则虽然不同，但就其内核，大多都可以看成是Nim游戏来思考。 对于更为一般的SG函数值求解，我们有以下方法： 可选步数为1~m的连续整数，直接取模即可，$SG(x) = x % (m+1)$; 可选步数为任意步，$SG(x) = x$; 可选步数为一系列不连续的数，可以自定义$GetSG()$函数计算。 自定义的$GetSG()$函数一般有两种形式，分别为打表和搜索。下面附上代码。 打表 1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1; for(j=0;j&lt;=n;j++) //求mex&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; 搜索 1234567891011121314151617181920212223242526272829//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍//n是集合s的大小 S[i]是定义的特殊取法规则的数组int s[110],sg[10010],n;//dfsint getSG(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125; 最后，附上一道实战题目和ac代码。斐波那契一次又一次 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 1000 + 10#define N 20int f[N],SG[MAXN],S[MAXN];void getSG(int n)&#123; int i,j; memset(SG,0,sizeof(SG)); for(i = 1; i &lt;= n; i++)&#123; memset(S,0,sizeof(S)); for(j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; j++) S[SG[i-f[j]]] = 1; for(j = 0;;j++) if(!S[j])&#123; SG[i] = j; break; &#125; &#125;&#125;int main()&#123; int n,m,k; f[0] = f[1] = 1; for(int i = 2; i &lt;= 16; i++) f[i] = f[i-1] + f[i-2]; getSG(1000); while(scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k),m||n||k)&#123; if(SG[n]^SG[m]^SG[k]) printf(&quot;Fibo\\n&quot;); else printf(&quot;Nacci\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"Hello-World","date":"2019-07-08T02:33:48.000Z","updated":"2019-07-08T02:33:48.650Z","comments":true,"path":"2019/07/08/Hello-World/","link":"","permalink":"http://yoursite.com/2019/07/08/Hello-World/","excerpt":"","text":"","categories":[],"tags":[]}]}