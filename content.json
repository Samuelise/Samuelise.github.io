{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Samuelise","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"A-brief-analysis-of-the-combined-game-model-in-game-theory","slug":"A-brief-analysis-of-the-combined-game-model-in-game-theory","date":"2019-07-07T15:16:39.000Z","updated":"2019-07-07T15:27:32.389Z","comments":true,"path":"2019/07/07/A-brief-analysis-of-the-combined-game-model-in-game-theory/","link":"","permalink":"http://yoursite.com/2019/07/07/A-brief-analysis-of-the-combined-game-model-in-game-theory/","excerpt":"","text":"�������������Ϸģ�͵��㷨ǳ���������������Ϸģ�͵��㷨ǳ������ ��������Game Theory),�ֳƶԲ���,���������ۣ�����˼�壬�����о����������Ŷ�֮�����ض�������Լ�µĶԾ���������ط��Ĳ��ԡ�������ĳ�ض���Ϸ�����£����������ж�֮ǰ��׼���õ�һ���������ж������� �����ۼ����ִ���ѧ��һ����֧��Ҳ���˳�ѧ��һ��ѧ��. �����Ϸ��Combinatorial Games����������Ϸͨ���������ص㣺 ��Ϸ�����������ߣ��������������������Ҷ��ߵľ��߶����Լ��������� ����һ���޷���������ʱ��Ϸ�����������޷��������ߵ��˸������۶�������������ߣ���Ϸ���������޲��ڽᣬ ��Ϸ��ĳһ��״̬�������ٴε����Ϸ�������ƽ���ľ��档 ����һ����������ĳһ��ȷ��״̬���������ľ��߼���ֻ�뵱ǰ״̬�йأ�����������޹ء� NP̬��������������һ������——–NP̬���� P-position�����ֱذ�̬�� N-position�����ֱ�ʤ̬�� �������£� ���߼���Ϊ�յľ�����P-position�� �����ƶ���P-position�ľ�����N-position�� �κξ��߾�ֻ���ƶ���N-position�ľ�����P-position�� �����ȿ�һ���⣬���ҵ�һ�νӴ��������Ϸ��Ҳ�ǵ�һ�νӴ��������۵��⡣��Ŀ���ӣ�pb����Ϸ ��Ϸ�����������ģ�pb���ֽ���������Ȼ���ָ�������������Ȼ������������֮�͵���ԭ����֮����zsѡ���������������е�һ�����зָ֮������pb����ѡ��ָ����ظ��� ��Ϸ����ǳ��򵥣�����֪��һ���򵥵Ľ��ۣ� ����=����+ż�� ż��=ż��+ż�� or ż��=����+���� �������£� ��������N, $N=1$ʱ��$N$�����ٱ��ָ��ʱ�õ�N�Ĳ����ߵľ���ΪP-position�����ֱذܡ� $N=2$ʱ��Nֻ�ܱ��ָ�Ϊ��1��1�����������ƶ�����P-position���������ʣ���ǰ $N=2$�ľ���ΪN-position�����ֱ�ʤ�� $N&gt;2$��$N$Ϊż��ʱ����ô��ֻ��Ҫ������$a+b$��$a$��$b$��ΪС��N����������ô�ҵĶ�������ѡ��$a$����$b$������Ȼ����һ��ż��������ֻҪѡ���Ǹ�ż�������ֻص���$N$Ϊż�����������ˣ���ѡ�������Զ��ż��������ѡ�����ֻ����������ѡ��$N=2$�Ļ�����Զ�������$N$Ϊż���ľ���ΪN-position�����ֱ�ʤ�� $N&gt;2$��$N$Ϊ����ʱ����ô�ҽ�����$a+b��a��b$�б�Ȼ��һ����ż��������������$N$�����������ѡ������ƶ���N-position����ˣ�NΪ�����ľ���ΪP-position�����ֱذܡ� ���ϣ�$N$Ϊ���������ֱذܣ�$N$Ϊż�������ֱ�ʤ�� �������£� 123456789101112131415#include &lt;cstdio&gt;int main()&#123; int n,a scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; scanf(&quot;%d&quot;, &amp;a); if (a &amp; 1)//�ж���ż�������Ļ����ֵ�pb�ذܣ�ż���Ļ����ֵ�pb��ʤ������ʹ��λ����ӿ��ٶȣ�����д printf(&quot;zs wins\\n&quot;); else printf(&quot;pb wins\\n&quot;); &#125; return 0;&#125; �����ǳ��򵥣����Ժ����׾��жϳ�NP״̬��Ӧ�ľ���ֱ���ʲô��������΢����һ����������Nim��Ϸ�����Ӧ��״̬���Ϸǳ���ֱ��ʹ��NP״̬�������ʱ�ǳ����ӣ�������Ȼ������⣬��Ч��Ҳ�Ǽ��͵ģ���Ϊ��Ҫ���ж�ÿһ��������N-position����P-position����ʹ�����ö�̬�滮����仯�����������Ż���Ҳ�����Ż�����������ĳ̶ȡ� ��ô�����ڴ������⣬��û��һ��ͨ����Ч�ʸߵ��㷨�أ� �����Ҫ�õ��������м�Ϊ��Ҫ�Ĺ��ߡ�����SG������SG�����������Ȳ���֤����������������� SG���� ���ȶ���$mex=(minimal excludant)$���㣬����ʩ����һ�����ϵ����㣬��ʾ��С�Ĳ�����������ϵķǸ�����������,$mex{0,1,2,4 }=3��mex{ 2,3,5}=0��mex{0 }=1$�� ��������״̬ $x$ �� ���� $SG(x) = mex(S)$,���� $S$ �� $x$ ���״̬��SG����ֵ�ļ��ϡ���$x$ ���������״̬�ֱ�Ϊ$a,b,c$����ô$SG(x) = mex{ SG��a��,SG��b��,SG��c��}$�� ����$$SG\\big(x) =mex{ SG\\big(y):y\\in S}$$ SGֵ������Ϊ�����SG(x) = 0����ôx�Ǳذ�̬�����SG(x) != 0,��ôx�Ǳ�ʤ̬�� Sprague-Grundy(SG)������������Ϸ��SG����ֵ��ÿ�������ϷSG����ֵ��Nim�͡� Nim����ָ�����������Ľ�� ���� $$SG\\big(x_1,x_2,\\ldots,x_n)=SG\\big(x_1)\\oplus SG(x_2)\\oplus\\cdots\\oplus SG(x_n)$$ �����������ٻع�ͷ����һ��Nim��Ϸ�� ��Ϸ��������Ϊ�������ɶ�ʯ�ӣ�ÿ��ʯ�ӵ������������޵ģ��Ϸ����ƶ��ǡ�ѡ��һ��ʯ�Ӳ��������ɿţ����ܲ��ã���������ֵ�ĳ����ʱ���е�ʯ�ӶѶ��Ѿ����ÿ��ˣ����и�����Ϊ���˿��޷������κκϷ����ƶ����� ��Ϊһ��ֻ�ܴ�ĳһ����ȡ�����������ȿ�ֻ��һ��ʯ�ӵ������ ������һ����n��ʯ�ӣ���ô��ȡ��ʯ������Ϊ1 ~ n�� $n=1$ʱ������ȡ��1����$SG[1] = mex{SG[0] }= mex{0 } = 1$��$n=2$ʱ������ȡ��1��2��$SG[2] = mex { SG[1]��SG[0] }= mex { 0,1} = 2$;$n=3$ʱ��$SG[3] = mex{SG[2],SG[1],SG[0] } = mex {0,1,2 }= 3$ ;…..�ɵ��±��� | n| 1 |2|3|4|5|6|7|…|n||–|–|–|–|–|–|–|–|–|–|–|–|–|–|| SG[n] | 1 |2 | 3 | 4 | 5|6|7|…|n| ��Ȼ��$SG[n]=n$�� ����$n$��ʯ��,$SG[n]=mex{0��1��2…n-1} = n$�� ��ô����m��ʯ�ӣ�����SG������ֻ�轫ÿһ�ѵ�SGֵ����������ɡ� �������£� 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;int t, n;int main() &#123; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int shu; scanf(&quot;%d&quot;, &amp;shu); ans ^= shu;//ʯ�ӵĸ�����Ϊ�ö�ʯ�ӵ�SGֵ &#125; if (!ans) printf(&quot;No\\n&quot;);//SGֵΪ0ʱ�����ֱذ� else printf(&quot;Yes\\n&quot;); &#125;&#125; ͨ������ķ������ѿ�����SG������ʵ���Ƕ�ÿһ�������NP״̬����ת�ơ� �������Ǹ����Ͻ�����ѧ֤���� �� $x=(x_1,x_2,…,x_n��, xΪ��ǰ״̬$ , $x’=(x_1,…,x_i’…,x_n),i\\in[1 \\cdots n]$, $b=SG(x_1)\\oplus SG(x_2)\\oplus \\cdots\\oplus SG(x_n)$. ��ʼ��������$0\\oplus0\\oplus0\\oplus\\cdots\\oplus0$,���е�����Ϸ��������ʱ����Ϸ�ͽ���������ʱΪP-position��$SG(x)=0$�� ֤������������ �������зǸ�����$a&lt;b$,�ض���һ��״̬$x’$,ʹ��$SG(x’)=a$. û��һ��$x$����״̬$x’$,ʹ��$SG(x’)=b$. ֤1.����$d=a\\oplus b,2^k&lt;=d&lt;2^k+1$�� ������$a$�ڵ�$k+1$λΪ0��$b$�ڵ�$k+1$Ϊ1����ô�ض���һ��$SG(x_i)$�ڶ����Ʊ�ʾ�ĵ�$k+1$λΪ1�� $SG��x_i)\\oplus d&lt;SG(x_i)$�����Աض���$SG��x_i’)=d\\oplus SG��x_i)$, ����,$$a=b\\oplus d=SG(x_1)\\oplus \\cdots \\oplus SG(x_n)\\oplus d=SG(x_1)\\oplus\\cdots\\oplus SG(x_i’)\\oplus\\cdots\\oplus SG(x_n)$$ ��������$x’$,ʹ��$SG(x’)=a$ ֤2.��$b=SG(x_1)\\oplus …\\oplus SG(x_i)\\oplus…\\oplus SG(x_n)$, $a=SG(x_1)\\oplus …\\oplus SG(x_i’)\\oplus…\\oplus SG(x_n)$, ��$a=b$�������$SG��x_i)=SG(x_i’)$������ζ���м�һ��û�н����κθĶ�����Ȼ���ǲ��������ġ�����������һ��x����״̬$x’$��ʹ��$SG��x’��=b$�� ���ϣ������֤�� ��Nim��Ϸ��˵�������������Ϸģ���н�Ϊ�������⣬��ֵ��ע����ǣ���ģ���£���ͬ��Ϸ�Ĺ�����Ȼ��ͬ���������ںˣ���඼���Կ�����Nim��Ϸ��˼���� ���ڸ�Ϊһ���SG����ֵ��⣬���������·����� ��ѡ����Ϊ1~m������������ֱ��ȡģ���ɣ�$SG(x) = x % (m+1)$; ��ѡ����Ϊ���ⲽ��$SG(x) = x$; ��ѡ����Ϊһϵ�в����������������Զ���$GetSG()$�������㡣 �Զ����$GetSG()$����һ����������ʽ���ֱ�Ϊ��������������渽�ϴ��롣 ��� 1234567891011121314151617181920212223//f[]������ȡ�ߵ�ʯ�Ӹ���//sg[]:0~n��SG����ֵ//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1; for(j=0;j&lt;=n;j++) //��mex&#123;&#125;��δ���ֵ���С�ķǸ����� &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; ���� 1234567891011121314151617181920212223242526272829//ע�� S����Ҫ����С�������� SG����Ҫ��ʼ��Ϊ-1 ����ÿ������ֻ���ʼ��1��//n�Ǽ���s�Ĵ�С S[i]�Ƕ��������ȡ�����������int s[110],sg[10010],n;//dfsint getSG(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125; ��󣬸���һ��ʵս��Ŀ��ac���롣쳲�����һ����һ�� 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 1000 + 10#define N 20int f[N],SG[MAXN],S[MAXN];void getSG(int n)&#123; int i,j; memset(SG,0,sizeof(SG)); for(i = 1; i &lt;= n; i++)&#123; memset(S,0,sizeof(S)); for(j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; j++) S[SG[i-f[j]]] = 1; for(j = 0;;j++) if(!S[j])&#123; SG[i] = j; break; &#125; &#125;&#125;int main()&#123; int n,m,k; f[0] = f[1] = 1; for(int i = 2; i &lt;= 16; i++) f[i] = f[i-1] + f[i-2]; getSG(1000); while(scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k),m||n||k)&#123; if(SG[n]^SG[m]^SG[k]) printf(&quot;Fibo\\n&quot;); else printf(&quot;Nacci\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[]}]}